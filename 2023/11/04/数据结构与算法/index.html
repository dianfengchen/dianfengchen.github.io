<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | 点风尘の博客</title><meta name="author" content="点风尘 (Ethan)"><meta name="copyright" content="点风尘 (Ethan)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录一下数据结构和算法这门课程的复习过程~">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://dianfengchen.github.io/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="点风尘の博客">
<meta property="og:description" content="记录一下数据结构和算法这门课程的复习过程~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2025/11/27/69273863d4308.png">
<meta property="article:published_time" content="2023-11-04T10:19:37.000Z">
<meta property="article:modified_time" content="2025-11-28T14:33:48.637Z">
<meta property="article:author" content="点风尘 (Ethan)">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2025/11/27/69273863d4308.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法",
  "url": "https://dianfengchen.github.io/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",
  "image": "https://bu.dusays.com/2025/11/27/69273863d4308.png",
  "datePublished": "2023-11-04T10:19:37.000Z",
  "dateModified": "2025-11-28T14:33:48.637Z",
  "author": [
    {
      "@type": "Person",
      "name": "点风尘 (Ethan)",
      "url": "https://dianfengchen.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dianfengchen.github.io/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 点风尘 (Ethan)","link":"链接: ","source":"来源: 点风尘の博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://bu.dusays.com/2025/11/29/692aa597c2c49.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-feather-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-history"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-theater-masks"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/anime/"><i class="fa-fw fas fa-wand-magic-sparkles"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-comments"></i><span> 社交</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(https://bu.dusays.com/2025/11/22/69218c1b4d582.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-feather-alt"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-history"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-theater-masks"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/anime/"><i class="fa-fw fas fa-wand-magic-sparkles"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-comments"></i><span> 社交</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-04T10:19:37.000Z" title="发表于 2023-11-04 18:19:37">2023-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-28T14:33:48.637Z" title="更新于 2025-11-28 22:33:48">2025-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>兄弟萌，距离数据结构与算法考试只剩十几天了。具体多少天我也不清楚，但是我觉得从现在开始复习还不晚。因为上课基本不听，都在自学，当然了，最主要还是听不懂，所以对待这种考试还是有必要冲一冲的，毕竟，我可不想挂科，下一年还要再听一次天书。</p>
<p>为了让我的复习之路不那么枯燥，我决定把复习过程中的知识点记录下来，并且还能以防日后忘记拿来温习温习，并且还能为博客增添内容，岂不三全其美。</p>
<p>对了，我复习参考的内容主要是B站小甲鱼老师的教程，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av21828275/?vd_source=983935ef48f0314e17fe40ec21ad7d3a">链接在此</a></p>
<p>OK，正片开始。</p>
<h1>Day0</h1>
<h2 id="算法的特性">算法的特性</h2>
<ul>
<li>输入：算法具有零个或多个输入。</li>
<li>输出：算法至少有一个或多个输出。</li>
<li>有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内都可以完成。一个永远都不会结束的算法，我们还要他来干啥？</li>
<li>确定性：
<ul>
<li>算法的每一个步骤都具有确定的含义，不会出现二义性。</li>
<li>算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果（这里的一定条件应该就是相同输入）。</li>
</ul>
</li>
<li>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</li>
</ul>
<h2 id="算法设计要求">算法设计要求</h2>
<ul>
<li>正确性：
<ul>
<li>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能够正确反映问题的需求、能够得到问题的正确答案。</li>
<li>大体分为以下四个层次：
<ul>
<li>算法程序没有语法错误。</li>
<li>算法程序对于合法输入能够产生满足要求的输出。</li>
<li>算法程序对于非法输入能够产生满足要求的说明。</li>
<li>算法程序对于故意刁难的测试输入都有满足要求的输出结果。（操作系统的缓冲区溢出）</li>
</ul>
</li>
</ul>
</li>
<li>可读性：
<ul>
<li>算法设计另一目的是为了便于阅读、理解和交流。</li>
<li>我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读和自己日后阅读修改。</li>
</ul>
</li>
<li>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果。</li>
<li>时间效率高和存储空间小。</li>
</ul>
<h2 id="算法效率的度量方法（准备环节）">算法效率的度量方法（准备环节）</h2>
<ul>
<li>事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</li>
<li>事前分析估算方法：在计算机程序编写前，依据统计方法对算法运行时间进行估算。</li>
</ul>
<p>如果非常较真的研究总共精确执行次数，那是非常累的。</p>
<p>另一方面，我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大的增长量的抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题，然后，然后就永远也没有然后了！</p>
<p>我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。</p>
<p>这样，不计那些循环索引的递增和循环终止条件（判断）、变量声明、打印结果等操作。最终，在分析程序的运行时间时，最重要的是<strong>把程序看成是独立于程序设计语言的算法或一系列步骤。</strong></p>
<p>我们在分析一个算法的运行时间时，重要的是<strong>把基本操作的数量和输入模式关联起来</strong></p>
<p>直接上结论吧，判断一个算法的效率时，函数中的常数和其它次要项常常可以忽略，而更应该关注主项（最高项）的阶数。</p>
<p>请注意：判断一个算法好不好，只通过少量的数据是不能做出准确判断的，很容易以偏概全。所以测试时数据一定要多，越多越精确。^_^</p>
<h1>Day1</h1>
<h2 id="算法时间复杂度">算法时间复杂度</h2>
<h3 id="定义">定义</h3>
<p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的<strong>增长率</strong>和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p>
<p>关键需要知道执行次数==时间</p>
<ul>
<li>这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。</li>
<li>一般情况下，随着输入规模n的扩大，T(n)增长最慢的算法为最优算法。</li>
<li>三个求和算法的时间复杂度O(1)（高斯算法）, O(n), O(n^2)</li>
</ul>
<h3 id="推导大O阶方法">推导大O阶方法</h3>
<p>攻略如下下：</p>
<ul>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。</li>
<li>得到的最后结果就是大O阶。</li>
</ul>
<h1>Day2</h1>
<h2 id="常见的时间复杂度">常见的时间复杂度</h2>
<ul>
<li>常见的时间复杂度所耗费的时间从小到大依次是：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</li>
<li>而像O(n^3)之后的这些，由于n值的增大都会使得结果大得难以想象，我们没必要去讨论它们。谁用谁傻B。</li>
</ul>
<h2 id="最坏情况与平均情况">最坏情况与平均情况</h2>
<ul>
<li>我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么时间复杂度为O(n)。</li>
<li>平均运行时间是期望的运行时间。</li>
<li>最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</li>
</ul>
<h2 id="算法的空间复杂度">算法的空间复杂度</h2>
<ul>
<li>算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中n为问题的规模，f(n)为语句关于n所占存储空间的函数。</li>
<li><strong><u>通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。</u></strong>（这句话据说经常考，但咱也不知道为什么^_^）</li>
<li>当直接要让我们求“复杂度”时，通常指的是时间复杂度。</li>
<li>显然对时间复杂度的追求更是属于算法的潮流。</li>
</ul>
<h2 id="线性表的定义">线性表的定义</h2>
<ul>
<li>线性表（List）：由零个（空表）或多个数据元素组成的有限序列。</li>
<li>敲黑板了
<ul>
<li>首先它是一个序列，也就是说元素之间是有个先来后到的，像刚才的<em>小蝌蚪</em>就没有顺序。</li>
<li>若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。</li>
<li>另外，线性表强调是有限的，事实上无论计算机发展到多强大，它所处理的元素都是有限的。</li>
</ul>
</li>
<li>数学语言的定义：（还得是我数学哥啊）
<ul>
<li>若将线性表记为（a1, …, ai-1, ai, ai+1, …,an），则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。</li>
<li>线性表的个数n(n&gt;=0)定义为线性表的长度，当n=0时，称为空表。</li>
</ul>
</li>
</ul>
<h2 id="抽象数据类型">抽象数据类型</h2>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>官方定义：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</li>
<li>例如很多编程语言的整型，浮点型，字符型这些指的就是数据类型。</li>
<li>例如在C语言中，按照取值的不同，数据类型可以分为两类：
<ul>
<li>原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。</li>
<li>结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组就是由若干整形数据组成的。</li>
</ul>
</li>
</ul>
<h3 id="抽象数据类型-2">抽象数据类型</h3>
<ul>
<li>抽象：是指抽取出事物具有的普遍性的本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。</li>
<li>我们对已有的数据类型进行抽象，就有了抽象数据类型。</li>
<li>抽象数据类型（Abstract Data Type, ADT）是指一个数学模型及定义在该模型上的一组操作。（是不是有点像类呢）</li>
<li>抽象数据模型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</li>
<li>比如1+1=2这样一个操作，在不同CPU的处理上可能不一样，执行的指令数量可能不一样，但由于其定义的数学特性相同，所以在计算机编程者看来，它们都是相同的。</li>
<li>“抽象数据类型”的意义在于数据类型的数学抽象特性。</li>
<li>而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型。</li>
<li>例如一个3D游戏中，要定位角色的位置，那么总会出现x, y, z三个整型数据组合在一起的坐标。我们就可以定义一个point的抽象数据类型，它拥有x, y, z三个整型变量，这样我们就可以方便的对一个角色的位置进行操作。</li>
<li>为了便于在之后的讲解中对抽象数据类型进行规范的描述，我们给出了描述抽象数据类型的标准格式：（伪代码）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">  数据元素之间逻辑关系的定义</span><br><span class="line">Operatio</span><br><span class="line">  操纵</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h1>Day3</h1>
<h2 id="线性表的抽象数据类型">线性表的抽象数据类型</h2>
<p>总结下线性表的抽象数据类型定义：</p>
<blockquote>
<p>ADT 线性表（List）</p>
<p>Data</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线性表的数据对象集合为&#123;a1, a2, ..., an&#125;，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素</span><br><span class="line"></span><br><span class="line">有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间是</span><br><span class="line"></span><br><span class="line">一对一的关系。</span><br></pre></td></tr></table></figure>
<p>Operation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">InitList(*L)：初始化操作，建立一个空的线性表L。</span><br><span class="line"></span><br><span class="line">ListEmpty(L)：判断线性表是否为空表，若线性表为空表，返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">ClearList(L, i, *e)：将线性表L中的第i个位置元素值返回给e。</span><br><span class="line"></span><br><span class="line">GetElem(L, i, *e)：将线性表L中的第i个位置元素值返回给e。</span><br><span class="line"></span><br><span class="line">LocateElem(L, e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否</span><br><span class="line"></span><br><span class="line">则，返回0表示失败。</span><br><span class="line"></span><br><span class="line">ListInsert(*L, i, e)：在线性表中第i个位置插入新元素e。</span><br><span class="line"></span><br><span class="line">ListDelete(\*L, i，\*e)：删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line"></span><br><span class="line">ListLength(L)：返回线性表L的元素个数。</span><br></pre></td></tr></table></figure>
<p>endADT</p>
</blockquote>
<p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// La表示A集合，Lb表示B集合。</span><br><span class="line">void unionL(List *La, list Lb)</span><br><span class="line">&#123;</span><br><span class="line">  int La_len, Lb_len, i;</span><br><span class="line">  </span><br><span class="line">  ElemType e;</span><br><span class="line">  La_len = ListLength(*La);</span><br><span class="line">  Lb_len = ListLength(Lb);</span><br><span class="line">  </span><br><span class="line">  for(i=1; i&lt;=Lb_len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    GetElem(Lb, i, &amp;e);</span><br><span class="line">    if(!LocateElem(*La, e))</span><br><span class="line">    &#123;</span><br><span class="line">      ListInsert(La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Day4</h1>
<h2 id="线性表的顺序存储结构">线性表的顺序存储结构</h2>
<ul>
<li>接下来看线性表顺序存储的结构代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 20</span><br><span class="line">typedef int ElemType</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  ElemType data[MAXSIZE];</span><br><span class="line">  int length;  // 线性表当前长度</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结下，顺序存储结构封装需要三个属性：
<ul>
<li>存储空间的起始位置，数组data，它的存储位置就是线性表存储空间的存储位置。</li>
<li>线性表的最大存储容量：数组的长度MaxSize。</li>
<li>线性表的当前长度：length。</li>
</ul>
</li>
<li>注意：数组的长度与线性表的当前长度需要区分一下，数组的长度是存放线性表的存储空间的总长度，一般初始化后不变。而线性表的当前长度是线性表中元素的个数，是会变化的。</li>
</ul>
<h3 id="地址计算方法">地址计算方法</h3>
<ul>
<li>假设ElemType占用的是c个存储单元（字节），那么线性表中第i+1个数据元素和第i个数据元素的存储位置的关系是（LOC表示获得存储位置的函数）：LOC(ai+1) = LOC(ai) + c</li>
<li>所以对于第i个数据元素ai的存储位置可以由ai推算得出：LOC(ai) = LOC(a1) + (i-1) * c</li>
<li>通过这个公式，我们可以随时计算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么它的存储时间性能当然就为O(1)，我们通常称为随机存储结构。</li>
</ul>
<h3 id="获得元素操作">获得元素操作</h3>
<p>实现GetElem的具体操作，即将线性表L中的第i个位置元素返回。就程序而言就非常简单了，我们只需要把数组第i-1下标的值返回即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">typedef int Status;</span><br><span class="line"></span><br><span class="line">// Status是函数的类型，其值是函数结果状态代码，如OK等。</span><br><span class="line">// 初始条件：顺序线性表L已存在，1 &lt;= i &lt;= ListLength(L)</span><br><span class="line"></span><br><span class="line">Status GetElem(SqList L, int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">  if(L.length==0 || i&lt;1 || i&gt;L.length)</span><br><span class="line">  &#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  *e = L.data[i-1]</span><br><span class="line">  </span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作">插入操作</h3>
<ul>
<li>刚才我们谈到，线性表的顺序存储结构具有随机存储结构的特点，时间复杂度为O(1)。</li>
</ul>
<h3 id="删除操作">删除操作</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status ListDelete(SqList *L, int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">  int k;</span><br><span class="line">  </span><br><span class="line">  if (L-&gt;length == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  if (i&lt;1 || i&gt;L-&gt;length)</span><br><span class="line">  &#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  *e = L-&gt;data[i-1];</span><br><span class="line">  if (i&lt;L-&gt;length)</span><br><span class="line">  &#123;</span><br><span class="line">    for (k=i, k&lt;L-&gt;length; k++)</span><br><span class="line">    &#123;</span><br><span class="line">      L-&gt;data[k-1] = L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;length--;</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最好的情况：插入和删除操作刚好要求在最后一个位置操作，因为不需要移动任何元素，所以此时的时间复杂度为O(1)。</li>
<li>最坏的情况：如果要插入和删除的位置是第一个元素，那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为O(n)。</li>
<li>至于平均情况，就取中间值O((n-1)/2)。</li>
<li>简化之后平均情况复杂度还是O(n)。</li>
</ul>
<h3 id="线性表顺序存储结构的优缺点">线性表顺序存储结构的优缺点</h3>
<ul>
<li>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)。而在插入或删除时，时间复杂度都是O(n)。</li>
<li>这就说明，它比较适合元素个数比较稳定，不经常插入和删除元素，而更多的操作是存取数据的应用。</li>
<li>优点：
<ul>
<li>无需为表示表中元素之间的逻辑关系而增加额外的存储空间。</li>
<li>可以快速地存取表中任意位置的元素。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>插入和删除操纵经常需要移动大量元素。</li>
<li>容易造成存储空间的“碎片”。（因为是一整块申请的）</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量。（暂时还不理解^_^）</li>
</ul>
</li>
</ul>
<h2 id="线性表的链式存储结构">线性表的链式存储结构</h2>
<h3 id="线性表链式存储结构定义">线性表链式存储结构定义</h3>
<ul>
<li>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。</li>
<li>比起顺序存储结构每个数据元素只需要存储一个位置就可以了。在链式存储结构中，除了要存储数据元素信息外，还要存储它的后继元素的存储地址（指针）。</li>
<li>也就是说除了存储其本身的信息外，还需存储一个指示其直接后继的存储位置的信息。</li>
<li>我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针或链。这两部分信息组成的数据元素称为存储映像，称为结点（Node）。</li>
<li>n个结点链接成一个链表，即为线性表（a1, a2, a3, …, an）的链式存储结构。</li>
<li>因为此链表的每个结点中只包含一个指针域，所以叫做单链表。</li>
<li>对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中的第一个结点的存储位置叫做头指针，最后一个结点的指针指向空（NULL）.</li>
</ul>
<p><img src="4c700da3a5f0889ee4695ac6a0606806.png" alt="4c700da3a5f0889ee4695ac6a0606806"></p>
<h3 id="单链表存储结构">单链表存储结构</h3>
<p><img src="4f8602473350fd7711f9a8f79cb10b4f.png" alt="4f8602473350fd7711f9a8f79cb10b4f"></p>
<p>我们在C语言中可以用结构指针来描述单链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">  ElemType data;  // 数据域</span><br><span class="line">  struct *Node Next;  // 指针域</span><br><span class="line">&#125; Node;</span><br><span class="line">typedef struct *Node LinkList;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的读取">单链表的读取</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 初始条件：顺序线性表L已存在，1&lt;=i&lt;=ListLength(L)</span><br><span class="line">// 操作结果：用e返回L中第i个数据元素的值</span><br><span class="line">Status GetElem(LinkList L, int i, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">  int j;</span><br><span class="line">  LinkList p;</span><br><span class="line">  </span><br><span class="line">  p = L-&gt;next;</span><br><span class="line">  j = 1;</span><br><span class="line">  </span><br><span class="line">  while(p &amp;&amp; j&lt;i)</span><br><span class="line">  &#123;</span><br><span class="line">    p = p-&gt;next</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!p || j&gt;i)</span><br><span class="line">  &#123;</span><br><span class="line">    return ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  *e = p-&gt;data;</span><br><span class="line">  return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Day5</h1>
<h2 id="栈的定义">栈的定义</h2>
<ul>
<li>栈是一种重要的线性结构，可以这样讲，栈是前面讲过的线性表的一种具体形式。</li>
<li>就像我们刚才的例子（弹夹装子弹），栈这种后进先出的数据结构应用是非常广泛的。在生活中，例如我们的浏览器，每点击一次“后退”都是退回到最近的一次浏览网页。</li>
<li>官方定义：栈（Stack）是一个<strong>后进先出</strong>（Last in first out, LIFO）的线性表，它要求<strong>只在表尾</strong>进行删除和插入操作。</li>
<li>小甲鱼定义：所谓的栈，其实也就是一个特殊的线性表（顺序表、链表），但是它在操作上有一些特殊的要求和限制：
<ul>
<li>栈的元素必须“后进先出”。</li>
<li>栈的操作只能在这个线性表的表尾进行。</li>
<li>注：对于栈来说，这个表尾称为栈的栈顶（top），相应的表头称为栈底（bottom）。</li>
</ul>
</li>
</ul>
<h2 id="栈的插入和删除操作">栈的插入和删除操作</h2>
<ul>
<li>栈的插入操作（Push），叫做进栈，也称为压栈，入栈。类似子弹放入弹夹的动作。</li>
<li>栈的删除操作（Pop），叫做出栈，也称为弹栈。如同弹夹中的子弹出夹。</li>
</ul>
<h2 id="栈的顺序存储结构">栈的顺序存储结构</h2>
<ul>
<li>因为栈的本质是一个线性表（一种特殊的线性表），线性表有两种存储形式，那么栈也分为栈的顺序存储结构和栈的链式存储结构。</li>
<li>最开始栈中不含有任何数据，叫做空栈，此时栈顶就是栈底。然后数据从栈顶进入，栈顶和栈底分离，整个栈的当前容量变大。数据出栈时从栈顶弹出，栈顶下移，整个栈的当前容量变小。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  ElemType *base;</span><br><span class="line">  ElemType *top;</span><br><span class="line">  int stackSize;</span><br><span class="line">&#125; sqStack;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里定义了一个顺序存储的栈，它包含了三个元素：base, top, stackSize。其中base是指向栈底的指针变量，top是指向栈顶的指针变量，stackSize指示栈的当前可使用的最大容量。</li>
</ul>
<h2 id="创建一个栈">创建一个栈</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define STACK_INIT_SIZE 100</span><br><span class="line">initStack(sqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">  s-&gt;base = (ElemType *)malloc(</span><br><span class="line">  STACK_INIT_SIZE * sizeof(ElemType));</span><br><span class="line">  if(!s-&gt;base)</span><br><span class="line">    exit(0);</span><br><span class="line">  s-&gt;top = s-&gt;base;  // 最开始，栈顶就是栈底</span><br><span class="line">  s-&gt;stackSize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入栈操作">入栈操作</h2>
<ul>
<li>入栈操作又叫压栈操作，就是向栈中存放数据。</li>
<li>入栈操作要在栈顶进行，每次向栈中压入一个数据，top指针就要+1，直到栈满为止。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define SATCKINCREMENT 10</span><br><span class="line">Push(sqStack *s, ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">  //如果栈满，追加空间</span><br><span class="line">  if(s-&gt;top - s-&gt;base &gt;= s-&gt;stackSize)</span><br><span class="line">  &#123;</span><br><span class="line">    s-&gt;base = (ElemType *)realloc(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT) * sizeof(ElemType));</span><br><span class="line">    if(!s-&gt;base)</span><br><span class="line">      exit(0);</span><br><span class="line">    </span><br><span class="line">    s-&gt;top = s-&gt;base + s-&gt;stackSize;  // 设置栈顶</span><br><span class="line">    s-&gt;stackSize = s-&gt;stackSize + STACKINCREMENT; // 设置栈的最大容量</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  *(s-&gt;top) = e;</span><br><span class="line">  s-&gt;top++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出栈操作">出栈操作</h2>
<ul>
<li>出栈操作就是在栈顶取出数据，栈顶指针随之下移的操作。</li>
<li>每当从栈内弹出一个数据，栈的当前容量就-1</li>
<li>代码清单：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pop(sqStack *s, ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">  if(s-&gt;top == s-&gt;base) // 栈已是空空是也</span><br><span class="line">    return;</span><br><span class="line">  *e = *--(s-&gt;top);  // 栈顶是不存放元素的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Day6</h1>
<h2 id="疑问解释">疑问解释</h2>
<ul>
<li>上节课我们讲解栈的结构，我们是这样声明的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  ElemType *base;</span><br><span class="line">  ElemType *top;</span><br><span class="line">  int stackSize;</span><br><span class="line">&#125; sqStack;</span><br></pre></td></tr></table></figure>
<ul>
<li>有些朋友提出了疑问：怎么没有data元素存放数据？怎么会有两个ElemType元素？</li>
<li>其实如果小甲鱼按照套路出牌，我们完全可以这样子声明：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  ElemType data[MAXSIZE];</span><br><span class="line">  int top;  // 用于标注栈顶的位置</span><br><span class="line">  int stackSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="d82c545686b5e324c04624015dfe5240.png" alt="d82c545686b5e324c04624015dfe5240"></p>
<p><img src="1b23d6cf60e939a3c801987f0ffc1fdf.png" alt="1b23d6cf60e939a3c801987f0ffc1fdf"></p>
<h2 id="清空一个栈">清空一个栈</h2>
<ul>
<li>所谓清空一个栈，就是将栈中的元素全部作废，但栈本身物理空间并不发生改变（不是销毁）。</li>
<li>因此我们只要将s-&gt;top的内容赋值为s-&gt;base即可，这样s-base等于s-&gt;top，也就表明这个栈是空的了。这个原理跟硬盘高级格式化只是单纯地清空文件列表（硬盘中各个文件的指针）而没有覆盖硬盘的原理是一样的。</li>
<li>代码清单：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClearStack(sqStack *s)&#123;</span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁一个栈">销毁一个栈</h2>
<ul>
<li>销毁一个栈与清空一个栈不同，销毁一个栈是要释放掉该栈所占据的物理内存空间，因此不要把销毁一个栈与清空一个栈这两种操作混淆。</li>
<li>代码清单</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DestroyStack(sqStack *s)&#123;</span><br><span class="line">    <span class="type">int</span> i, len;</span><br><span class="line">    len = s-&gt;stackSize;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;base);</span><br><span class="line">        s-&gt;base++;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;base = s-&gt;stop = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;stackSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算栈的当前容量">计算栈的当前容量</h2>
<ul>
<li>计算栈的当前容量也就是计算栈中元素的个数，因此只要返回s.top-s.base即可。</li>
<li>注意，栈的最大容量是指该栈占据内存空间的大小，其值是s.stackSize，它与栈的当前容量不是一个概念哦。</li>
<li>代码清单：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StackLen</span><span class="params">(sqStack s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(s.top-s.base);  <span class="comment">// 这里实际上是除以sizeof(ElemType)之后的，C和C++比我们想象的更智能</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另外指针之间是不能相加的</span></span><br></pre></td></tr></table></figure>
<h2 id="实例分析">实例分析</h2>
<p><img src="Snipaste_2023-11-20_14-53-36.png" alt="Snipaste_2023-11-20_14-53-36"></p>
<p><img src="Snipaste_2023-11-20_15-02-24.png" alt="Snipaste_2023-11-20_15-02-24"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *base;</span><br><span class="line">    ElemType *top;</span><br><span class="line">    <span class="type">int</span> stackSize;</span><br><span class="line">&#125;sqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(sqStack *s)</span>&#123;</span><br><span class="line">    s-&gt;base = (ElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;top = s-&gt;base;</span><br><span class="line">    s-&gt;stackSize = STACK_INIT_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(sqStack *s, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top - s-&gt;base &gt;= s-&gt;stackSize)&#123;</span><br><span class="line">        s-&gt;base = (ElemType *)<span class="built_in">realloc</span>(s-&gt;base, (s-&gt;stackSize + STACKINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!s-&gt;base)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(s-&gt;top) = e;</span><br><span class="line">    s-&gt;top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(sqStack *s, ElemType *e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;top == s-&gt;base)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = *--(s-&gt;top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackLen</span><span class="params">(sqStack s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s.top - s.base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ElemType c;</span><br><span class="line">    sqStack s;</span><br><span class="line">    <span class="type">int</span> len, i, sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    InitStack(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入二进制数，输入#符号表示结束！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        Push(&amp;s, c);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getchar();  <span class="comment">// 把&#x27;\n&#x27;从缓冲区去掉</span></span><br><span class="line">    </span><br><span class="line">    len = StackLen(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈的当前容量是：%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        Pop(&amp;s, &amp;c);</span><br><span class="line">        sum = sum + (c<span class="number">-48</span>) * <span class="built_in">pow</span>(<span class="number">2</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转化为十进制数是：%d\n&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从二进制到八进制">从二进制到八进制</h2>
<ul>
<li>地球人都知道，我们学习编程常常会接触到不同进制的数，而最多的就是二进制、八进制、十进制、十六进制。</li>
<li>鱼C人还知道，二进制是计算机唯一认识的，十进制是人们通常使用的。</li>
<li>那么，有没有谁知道八进制和十六进制呢？为什么没有三进制、四进制、五六七进制呢？</li>
<li>嗯，我们仔细观察二进制跟十六进制的对应关系：</li>
</ul>
<p><img src="Snipaste_2023-11-20_23-01-31.png" alt="Snipaste_2023-11-20_23-01-31"></p>
<ul>
<li>可见一个字节（8bit）刚好用两个十六进制数可以表示完整，也大大地节省了显示空间。</li>
<li>那八进制呢？因为早期的计算机系统都是三的倍数，所以用八进制比较方便。</li>
<li>我们发现了，在进行二进制到八进制的转换时，要将二进制数的每三位转换成一个八进制数来表示，然后按顺序输出即可。</li>
<li>对于文字描述不好理解的概念，我们就只能：</li>
</ul>
<p><img src="Snipaste_2023-11-20_23-48-59.png" alt="Snipaste_2023-11-20_23-48-59"></p>
<h1>Day7</h1>
<h2 id="字符串">字符串</h2>
<ul>
<li>以前的计算机刚被发明的时候，主要作用是做一些科学和工程的计算工作。</li>
<li>刚开始的计算机都是处理数值工作，后来引入了字符串的概念，计算机开始可以处理非数值的概念了（当然原理还是用数值来模拟非数值，通过ASCII表）。</li>
<li>我们先来研究下“串”（字符串）这样的数据结构：
<ul>
<li>定义：串（String）是由零个或多个字符组成的有限序列，又名叫字符串。</li>
<li>一般记为s = “a1a2a3…an” (n&gt;=0)</li>
<li>串可以是空串，即没有字符，直接由“”表示（注意里面没有空格哦~），或者可以用希腊字符Φ来表示（读fai，四声）。</li>
</ul>
</li>
<li>子串与主串，例如“FishC”是“<a target="_blank" rel="noopener" href="http://FishC.com">FishC.com</a>”的子串，反之则倒过来。</li>
</ul>
<h2 id="字符串的比较">字符串的比较</h2>
<ul>
<li>字符串比较大小跟传统的数字比较有点差别，很容易我们可以知道2比1要大，可要是“FishC”和“<a target="_blank" rel="noopener" href="http://fishc.com">fishc.com</a>”呢？要怎么比较？比长短？比大小？</li>
<li>比大小！没错，比的就是字符串里每个字符的ASCII码大小，因为’F’ ==  70  ‘f’==102，‘f’&gt;‘F’，所以&quot;<a target="_blank" rel="noopener" href="http://fishc.com">fishc.com</a>&quot; &gt; “FishC”</li>
<li>其实这样的比较大小没有多大意义，字符串的比较我们更重视是否相等！</li>
</ul>
<h2 id="字符串的存储结构">字符串的存储结构</h2>
<ul>
<li>字符串的存储结构与线性表相同，也分为顺序存储结构和链式存储结构。</li>
<li>字符串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列的。</li>
<li>按照预定义的大小，为每个定义的字符串变量分配一个固定长度的存储区，一般用定长数组来定义。</li>
<li>与线性表相似，既然是固定长度的存储区，就存在一个空间分配不灵活的问题，那么会考虑用链式存储结构。</li>
<li>不同的是字符串我们一般都是连在一起表述的，“断章取义“的情况并不多，所以习惯上我们通常还是会直接定义一个足够长度的存储区来存储的。</li>
</ul>
<h2 id="BF算法">BF算法</h2>
<ul>
<li>
<p>事实上，BF算法并不是“BoyFriend”算法的意思，他有一个很黄很暴力的原名：Brute Force</p>
</li>
<li>
<p>BF算法属于朴素（效率非常低）的模式匹配算法，它的核心思想是：</p>
<ul>
<li>有两个字符串S和T，长度为N和M。首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则S向右移动一个字符的位置，再依次进行比较。</li>
<li>该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)</li>
</ul>
</li>
<li>
<p>在这里S是主串，T是子串，这种子串的定位操作通常称作串的模式匹配。</p>
</li>
</ul>
<h1>Day8</h1>
<ul>
<li>
<p>KMP算法是三位老前辈（D.E.Knuth, J.H.Morris和V.R.Pratt）的研究成果，大大地避免了重复遍历的情况，全程叫做克努特-莫里斯-普拉特算法，简称KMP算法或看毛片算法。</p>
</li>
<li>
<p>KMP算法的核心就是避免不必要的回溯，那么什么是不必要的呢？问题由模式串决定，不是由目标决定！</p>
</li>
</ul>
<h2 id="思路启发">思路启发</h2>
<h3 id="1">1</h3>
<p><img src="Snipaste_2023-11-25_23-56-25.jpg" alt="Snipaste_2023-11-25_23-56-25"></p>
<h3 id="2">2</h3>
<p><img src="Snipaste_2023-11-26_00-31-32.jpg" alt="Snipaste_2023-11-26_00-31-32"></p>
<h3 id="3">3</h3>
<p><img src="Snipaste_2023-11-26_00-38-02.jpg" alt="Snipaste_2023-11-26_00-38-02"></p>
<h3 id="4">4</h3>
<h2 id="注重思考不要注重结果">注重思考不要注重结果</h2>
<p>对我很有启发，所以特地摘抄下来分享给各位！</p>
<ul>
<li>如果平时有阅读鸟文（英文）计算机书籍的朋友会发现很多教学书籍都有课后习题，但大部分不会附带答案，世面也不会有所谓的“答案全解”。</li>
<li>其实在老外的教学中，他们更加注重思考而非正确的结果。回想我们之所以会这么在意答案完全是中国式教育的产物，在我们的学校，分数就是一切！</li>
<li>在小甲鱼的教学中，我希望大家可以培养独立思考的精神，因为这是创新的根源所在！</li>
<li>希望你们可以通过以上引导，自己推导出KMP算法的原理！</li>
</ul>
<h1>Day9(KMP算法之养成篇)</h1>
<ul>
<li>这次我们给模式匹配串添加一个k数组（也就是KMP算法书中的next数组）。</li>
<li>这是一个“智能”的数组，因为他指导着模式匹配串下一步改用第几号元素去进行匹配。</li>
<li><strong>前缀和后缀的概念尤其重要，前缀和后缀是对于失配的位置来说的</strong>
<ul>
<li>第一个元素永远是前缀，失配的位置紧挨着的永远是后缀</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-11-26_13-29-21.jpg" alt="Snipaste_2023-11-26_13-29-21"></p>
<p><img src="Snipaste_2023-11-26_13-30-27.jpg" alt="Snipaste_2023-11-26_13-30-27"></p>
<p><img src="Snipaste_2023-11-26_13-31-31.jpg" alt="Snipaste_2023-11-26_13-31-31"></p>
<p><img src="Snipaste_2023-11-26_13-32-37.jpg" alt="Snipaste_2023-11-26_13-32-37"></p>
<h2 id="KMP算法之NEXT数组代码原理分析">KMP算法之NEXT数组代码原理分析</h2>
<p>NEXT数组：当模式匹配串T失配的时候，NEXT数组对应的元素指导应该用T串的哪个元素进行下一轮的匹配。（目标串S）</p>
<p>i (前缀)</p>
<p>j (后缀)</p>
<h1>Day10</h1>
<h2 id="树的定义">树的定义</h2>
<p><img src="Snipaste_2023-11-26_16-45-47.jpg" alt="Snipaste_2023-11-26_16-45-47"></p>
<ul>
<li>
<p>虽然从概念上很容易理解树，但是有两点还是需要注意下：</p>
<ul>
<li>
<p>n&gt;0时，根节点是唯一的，坚决不可能存在多个根节点。</p>
</li>
<li>
<p>m&gt;0时，子树的个数是没有限制的，但它们互相之间是一定不会相交的。</p>
</li>
<li>
<p><img src="Snipaste_2023-11-26_16-50-33.jpg" alt="Snipaste_2023-11-26_16-50-33"></p>
</li>
</ul>
</li>
</ul>
<h2 id="节点分类">节点分类</h2>
<ul>
<li>刚才所有图片中，每一个圈圈我们就称为树的一个节点。节点拥有的子树数称为节点的度（Degree），树的度取树内各节点的度的最大值。
<ul>
<li>度为0的节点称为叶节点（Leaf）或终端节点；</li>
<li>度不为0的节点称为分支节点或非终端节点，除根节点外，分支节点也称为内部节点。</li>
<li><img src="Snipaste_2023-11-26_16-59-14.jpg" alt="Snipaste_2023-11-26_16-59-14"></li>
</ul>
</li>
</ul>
<h2 id="节点间的关系">节点间的关系</h2>
<p><img src="Snipaste_2023-11-26_17-05-46.jpg" alt="Snipaste_2023-11-26_17-05-46"></p>
<h2 id="节点的层次">节点的层次</h2>
<p><img src="Snipaste_2023-11-26_17-07-14.jpg" alt="Snipaste_2023-11-26_17-07-14"></p>
<h2 id="其他概念">其他概念</h2>
<ul>
<li>如果将树中节点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</li>
<li>森林（Forest）是m(m&gt;0)棵互不相交的树的集合。对树中的每个节点而言，其子树的集合即为森林。</li>
</ul>
<h1>Day11</h1>
<h2 id="树的存储结构">树的存储结构</h2>
<ul>
<li>要存储树，简单的顺序存储结构和链式存储结构是不能滴！不过如果充分利用它们各自的特点，完全可以间接地来实现。</li>
<li>大家先思考下，如果你是总工程师，让你来设计和规划，你有多少种方法可以实现对树结构的存放？</li>
<li>当然你要考虑到双亲、孩子、兄弟之间的关系。</li>
<li>小甲鱼这里要介绍三种不同的表示法：双亲表示法、孩子表示法、双亲孩子表示法。</li>
</ul>
<h3 id="双亲表示法">双亲表示法</h3>
<ul>
<li>
<p>双亲表示法，言外之意就是以双亲作为索引的关键词的一种存储方式。</p>
</li>
<li>
<p>我们假设以一组连续空间存储树的节点，同时在每个节点中，附设一个指示其双亲节点在数组中位置的元素。</p>
</li>
<li>
<p>也就是说，每个节点除了知道自己是谁之外，还知道它的粑粑麻麻在哪里。</p>
</li>
<li>
<p>那么我们可以做如下定义：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的双亲表示法节点结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="type">int</span> parent;  <span class="comment">// 双亲位置</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r;  <span class="comment">// 根的位置</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 节点数目</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><img src="Snipaste_2023-11-26_18-41-34.jpg" alt="Snipaste_2023-11-26_18-41-34"></p>
</li>
<li>
<p>这样的存储结构，我们可以根据某节点的parent指针（这里也就是数组下标）找到它的双亲节点，所用的时间复杂度是O(1)，索引到parent的值为-1时，表示找到了树节点的根。</p>
</li>
<li>
<p>可是，如果我们要哦知道某节点的孩子是什么？那么不好意思，请遍历整个树结构。</p>
</li>
<li>
<p>这真是麻烦，能不能改进一下呢？</p>
</li>
<li>
<p>鱼友们怎么看？</p>
</li>
<li>
<p>电脑前的小盆友们怎么看？</p>
</li>
<li>
<p><img src="Snipaste_2023-11-26_18-50-56.jpg" alt="Snipaste_2023-11-26_18-50-56"></p>
</li>
<li>
<p>那现在我们又比较关心它们兄弟之间的关系呢？</p>
<ul>
<li><img src="Snipaste_2023-11-26_18-53-35.jpg" alt="Snipaste_2023-11-26_18-53-35"></li>
</ul>
</li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>存储结构的设计是一个非常灵活的过程，只要你愿意，你可以设计出任何你想要的奇葩！</li>
<li>一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等等。而不是取决于这个东西是否权威，从来没有权威这回事，只有更新换代。</li>
<li>不要拘泥于你所学过的有限的数据类型，像我们的Python脚本语言就没有任何数据类型。要把思维放开些，放开些，放开些！</li>
<li>当你的思维放开了，世界就变小了！</li>
<li>当你的思维放开了，知识就变少了！</li>
</ul>
<h3 id="孩子表示法">孩子表示法</h3>
<p><img src="Snipaste_2023-11-27_13-24-03.jpg" alt="Snipaste_2023-11-27_13-24-03"></p>
<p><img src="Snipaste_2023-11-27_13-26-01.jpg" alt="Snipaste_2023-11-27_13-26-01"></p>
<p><img src="Snipaste_2023-11-27_13-28-27.jpg" alt="Snipaste_2023-11-27_13-28-27"></p>
<p>方案二主要是时间换空间</p>
<p><img src="Snipaste_2023-11-27_13-38-46.jpg" alt="Snipaste_2023-11-27_13-38-46"></p>
<h3 id="双亲孩子表示法">双亲孩子表示法</h3>
<p><img src="Snipaste_2023-11-27_13-46-28.jpg" alt="Snipaste_2023-11-27_13-46-28"></p>
<ul>
<li>说了这么多，我们一起来把代码落实起来把！</li>
<li>最后还有一款是孩子兄弟表示法，构造方式也是大同小异，就交给大家课后去思考啦。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 孩子节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> child;  <span class="comment">// 孩子节点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个孩子节点的指针</span></span><br><span class="line">&#125; CTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 存放在树中节点的数据</span></span><br><span class="line">    <span class="type">int</span> parent;  <span class="comment">// 存放双亲的位置下标</span></span><br><span class="line">    CTNode *firstchild;  <span class="comment">// 指向第一个孩子的指针</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];  <span class="comment">// 节点数组</span></span><br><span class="line">    <span class="type">int</span> r, n;  <span class="comment">// 根的位置，节点数目</span></span><br><span class="line">&#125; PCTree;</span><br></pre></td></tr></table></figure>
<h1>Day12</h1>
<h2 id="二叉树的定义">二叉树的定义</h2>
<ul>
<li>世上树有万千种，唯有二叉课上讲。这里的二叉是二叉树，因为二叉树使用的范围最广，最具有代表意义，因此我们重点讨论二叉树。</li>
<li>二叉树（Binary Tree）是n（n&gt;=0）个节点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两颗互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</li>
<li>这个定义显然是递归形式的，所以咱看上去有点晕，因为自古有“神使用递归，人使用迭代！”</li>
</ul>
<p><img src="Snipaste_2023-11-27_17-21-36.jpg" alt="Snipaste_2023-11-27_17-21-36"></p>
<h2 id="二叉树的特点">二叉树的特点</h2>
<ul>
<li>每个节点最多有两棵子树，所以二叉树中不存在度大于2的情况。（注意：不是都需要两棵子树，而是最多两棵，没有子树或者有一棵子树也都是可以的。）</li>
<li>左子树和右子树是有顺序的，次序不能颠倒。</li>
<li>即使树中某节点只有一棵子树，也要区分它是左子树还是右子树，下面是完全不同的二叉树：</li>
</ul>
<p><img src="Snipaste_2023-11-27_17-29-23.jpg" alt="Snipaste_2023-11-27_17-29-23"></p>
<h2 id="二叉树的五种基本形态">二叉树的五种基本形态</h2>
<p><img src="Snipaste_2023-11-27_17-31-48.jpg" alt="Snipaste_2023-11-27_17-31-48"></p>
<h2 id="二叉树很二">二叉树很二</h2>
<p><img src="Snipaste_2023-11-27_17-37-01.jpg" alt="Snipaste_2023-11-27_17-37-01"></p>
<h2 id="特殊二叉树">特殊二叉树</h2>
<ul>
<li>因为他很二，所以他也很特殊。小甲鱼接下来再介绍一下一些特殊的二叉树，虽然暂时你可能不能理解它们的用处，但我们有必要先了解一下。</li>
</ul>
<h3 id="斜树">斜树</h3>
<ul>
<li>顾名思义，斜树是一定要斜的，但斜也要斜得有范儿，例如：</li>
<li><img src="Snipaste_2023-11-27_22-07-05.jpg" alt="Snipaste_2023-11-27_22-07-05"></li>
<li>要么往左斜，要么往右斜，不能一会往左，一会往右。</li>
</ul>
<h3 id="满二叉树">满二叉树</h3>
<ul>
<li>坡坡有云：“人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。”意思就是说完美的那是理想，不完美的才是人生。</li>
<li>但是对于二叉树来说，是否存在完美呢？有滴，那就是满二叉树啦。</li>
<li>在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</li>
<li><img src="Snipaste_2023-11-27_22-14-23.jpg" alt="Snipaste_2023-11-27_22-14-23"></li>
<li>满二叉树的特点有：
<ul>
<li>叶子只能出现在最下一层</li>
<li>非叶子节点的度一定是2</li>
<li>在同样深度的二叉树中，满二叉树的节点个数一定最多，同时叶子也是最多。</li>
</ul>
</li>
<li>满二叉树和完全二叉树历年都是一个重大考点，因为考生很容易混淆两者，但如果只是为了深入学习编程，那么只需要理解即可。记得我们曾说过：理解越多，需要记住的就越少！</li>
<li>对一棵具有n个节点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=n)的节点与同样深度的满二叉树中编号为i的节点位置完全相同，则这棵二叉树称为完全二叉树。</li>
<li><img src="Snipaste_2023-11-27_22-25-47.jpg" alt="Snipaste_2023-11-27_22-25-47"></li>
<li>完全二叉树的特点有：
<ul>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数第二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果节点度为1，则该节点只有左孩子。</li>
<li>同样节点数的二叉树，完全二叉树的深度最小。</li>
</ul>
</li>
<li>注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</li>
<li>以下这些都不是完全二叉树：</li>
<li><img src="Snipaste_2023-11-27_22-43-13.jpg" alt="Snipaste_2023-11-27_22-43-13"></li>
<li><img src="Snipaste_2023-11-27_22-44-56.jpg" alt="Snipaste_2023-11-27_22-44-56"></li>
<li><img src="Snipaste_2023-11-27_22-45-38.jpg" alt="Snipaste_2023-11-27_22-45-38"></li>
</ul>
<h1>Day13</h1>
<h2 id="二叉树的性质">二叉树的性质</h2>
<h3 id="性质一：">性质一：</h3>
<p>在二叉树的第i层上至多有2^(i-1)个节点</p>
<ul>
<li>这个性质其实很好记忆，考试的时候懂的画出二叉树的图便可以推出</li>
</ul>
<h3 id="性质二：">性质二：</h3>
<p>深度为k的二叉树至多有2^k-1个节点（k&gt;=1）</p>
<ul>
<li>这里一定要看清楚哦，是2^k再-1</li>
</ul>
<h3 id="性质三：">性质三：</h3>
<p>对任何一棵二叉树T，如果其终端节点数为n0，度为2的节点数为n2，则n0=n2+1</p>
<ol>
<li>这个就比较困难了，需要推导获得</li>
<li>首先我们假设度为1的节点数为n1，则二叉树T的节点总数n=n0+n1+n2</li>
<li>其次我们发现连接数总是等于总结点数n-1，并且等于n1+2*n2</li>
<li>所以n-1=n1+2*n2</li>
<li>所以n0+n1+n2-1=n1+n2+n2</li>
<li>最后n0=n2+1</li>
</ol>
<p><img src="Snipaste_2023-11-28_23-55-20.jpg" alt="Snipaste_2023-11-28_23-55-20"></p>
<h3 id="性质四：">性质四：</h3>
<p>具有n个节点的完全二叉树的深度为<br>
$$<br>
\lfloor\log_2n\rfloor+1<br>
$$<br>
由满二叉树的定义结合性质二我们知道，深度为k的满二叉树的节点数n一定是2^k-1</p>
<p>那么对于满二叉树我们可以通过n=2^k-1倒推出满二叉树的深度为<br>
$$<br>
log_2(n+1)<br>
$$<br>
由于完全二叉树前面我们已经提到，它的叶子节点只会出现在最下面的两层，我们可以同样如下推导：</p>
<ul>
<li>
<p>那么对于倒数第二层的满二叉树我们同样很容易回推出它的节点数为n=2^(k-1)-1</p>
</li>
<li>
<p>所以完全二叉树的节点数的取值范围是：2^(k-1)-1 &lt; n &lt;= 2^k-1</p>
</li>
<li>
<p>由于n是整数，n &lt;= 2^k-1可以看成n &lt; 2^k</p>
</li>
<li>
<p>同理2^(k-1)-1 &lt; n可以看成2^(k-1) &lt;= n</p>
</li>
<li>
<p>所以2^(k-1) &lt;= n &lt; 2^k</p>
</li>
<li>
<p>不等式两边同时取对数，得到<br>
$$<br>
k-1&lt;=log_2n&lt;k<br>
$$<br>
由于k是深度，必须取整，所以<br>
$$<br>
k=\lfloor log_2n+1\rfloor+1<br>
$$</p>
</li>
</ul>
<h3 id="性质五：">性质五：</h3>
<p>如果对一棵有n个节点的完全二叉树（其深度为）<br>
$$<br>
\lfloor\log_2n\rfloor+1<br>
$$<br>
的节点按层序编号，对任一节点i (1&lt;=i&lt;=n)有以下性质：</p>
<ul>
<li>
<p>如果i=1，则节点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是节点<br>
$$<br>
\lfloor i/2\rfloor<br>
$$</p>
</li>
<li>
<p>如果2i&gt;n，则节点i无左孩子（节点i为叶子节点）；否则其左孩子是节点2i</p>
</li>
<li>
<p>如果2i+1&gt;n，则节点i无右孩子；否则其右孩子是节点2i+1</p>
</li>
</ul>
<p><img src="Snipaste_2023-12-05_10-18-47.jpg" alt=""></p>
<h2 id="二叉树的存储结构">二叉树的存储结构</h2>
<ul>
<li>树结构在计算机中的存储形式很多，可谓天马行空任你创造，只要能够按照要求完成任务即可。</li>
<li>在前面的演示中，我们发觉很难单单只用顺序存储结构或者链式存储结构来存放。</li>
<li>但是二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构或链式存储结构都能够简单实现。</li>
<li>二叉树的顺序存储结构就是用一维数组存储二叉树中的各个节点，并且节点的存储位置能体现节点之间的逻辑关系。</li>
</ul>
<h3 id="二叉树的顺序存储结构">二叉树的顺序存储结构</h3>
<p><img src="Snipaste_2023-12-05_13-40-12.jpg" alt="Snipaste_2023-12-05_13-40-12"></p>
<p><img src="Snipaste_2023-12-05_13-41-29.jpg" alt="Snipaste_2023-12-05_13-41-29"></p>
<p><img src="Snipaste_2023-12-05_13-42-32.jpg" alt="Snipaste_2023-12-05_13-42-32"></p>
<h3 id="二叉链表">二叉链表</h3>
<ul>
<li>既然顺序存储方式的适用性不强，那么我们就要考虑链式存储结构了。二叉树的存储按照国际惯例来说一般也是采用链式存储结构的。</li>
<li>二叉树每个节点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</li>
</ul>
<p><img src="Snipaste_2023-12-05_13-47-29.jpg" alt="Snipaste_2023-12-05_13-47-29"></p>
<ul>
<li>以下是我们的二叉链表的节点结构定义代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="Snipaste_2023-12-05_13-51-11.jpg" alt="Snipaste_2023-12-05_13-51-11"></p>
<h1>Day14</h1>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<ul>
<li>
<p>二叉树的遍历 (traversing binary tree) 是指从根节点出发，按照某种<strong>次序</strong>依次<strong>访问</strong>二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。</p>
</li>
<li>
<p>这里有两个关键词小甲鱼给加红了：次序和访问</p>
</li>
<li>
<p>二叉树的遍历次序不同于线性结构，线性结构最多也就是分为顺序、循环、双向等简单的遍历方式。</p>
</li>
<li>
<p>树的节点之间不存在唯一的前驱和后继这样的关系，在访问一个节点后，下一个被访问的节点面临着不同的选择。这就像我们的人生，漫漫长途上一步踏错，满盘皆输！</p>
</li>
<li>
<p>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为以下四种：</p>
<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层序遍历</li>
</ul>
</li>
<li>
<p>前序遍历：</p>
<ul>
<li>若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-05_21-25-41.jpg" alt="Snipaste_2023-12-05_21-25-41"></p>
<ul>
<li>中序遍历：
<ul>
<li>若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-05_22-07-08.jpg" alt="Snipaste_2023-12-05_22-07-08"></p>
<ul>
<li>后序遍历：
<ul>
<li>若树为空，则空操作返回，否则从左到右先叶子节点的方式遍历访问左右子树，最后访问根节点。</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-05_22-25-43.jpg" alt="Snipaste_2023-12-05_22-25-43"></p>
<ul>
<li>层序遍历：
<ul>
<li>若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对节点逐个访问。</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-05_22-28-21.jpg" alt="Snipaste_2023-12-05_22-28-21"></p>
<h1>Day15</h1>
<h2 id="赫夫曼树">赫夫曼树</h2>
<ul>
<li>在数据膨胀、信息爆炸的今天，数据压缩的意义不言而喻。谈到数据压缩，就不能不提赫夫曼（Huffman）编码，赫夫曼编码是首个实用的压缩编码方案，即使在今天的许多知名压缩算法里，依然可以见到赫夫曼编码的影子。</li>
<li>另外，在数据通信中，用二进制给每个字符进行编码时不得不面对的一个问题是如何使电文总长度最短且不产生二义性。根据字符出现频率，利用赫夫曼编码可以构造出一种不等长的二进制，使编码后的电文长度最短，且保证不产生二义性。</li>
</ul>
<h3 id="赫夫曼树定义与原理">赫夫曼树定义与原理</h3>
<ul>
<li>我们先把这两颗二叉树简化成叶子结点带权的二叉树（注：树节点之间的连线相关的数叫做权，Weight）。</li>
</ul>
<p><img src="Snipaste_2023-12-06_14-45-45.jpg" alt="Snipaste_2023-12-06_14-45-45"></p>
<ul>
<li>节点的路径长度：
<ul>
<li>从根节点到该节点的路径上的连接数。</li>
</ul>
</li>
<li>树的路径长度：
<ul>
<li>树中各个叶子结点的路径长度之和。</li>
</ul>
</li>
<li>节点带权路径长度：
<ul>
<li>节点的路径长度与节点权值的乘积。</li>
</ul>
</li>
<li>树的带权路径长度：
<ul>
<li>WPL (Weighted Path Length) 是树中所有叶子结点的带权路径长度之和。</li>
</ul>
</li>
<li>WPL的值越小，说明构造出来的二叉树性能越优。</li>
<li>那么现在的问题是，如何构造出最优的赫夫曼树（最优二叉树）呢？别急，赫夫曼大叔给出了我们解决的方案。</li>
</ul>
<p><img src="Snipaste_2023-12-06_15-03-31.jpg" alt="Snipaste_2023-12-06_15-03-31"></p>
<p><img src="Snipaste_2023-12-06_15-05-29.jpg" alt="Snipaste_2023-12-06_15-05-29"></p>
<p><img src="Snipaste_2023-12-06_15-06-59.jpg" alt="Snipaste_2023-12-06_15-06-59"></p>
<p><img src="Snipaste_2023-12-06_15-07-51.jpg" alt="Snipaste_2023-12-06_15-07-51"></p>
<h2 id="赫夫曼编码">赫夫曼编码</h2>
<ul>
<li>
<p>上一节课我们已经谈了赫夫曼树的基本原理和构造方式，而赫夫曼编码可以很有效地压缩数据（通常可以节省20%~90%的空间，具体压缩率依赖于数据的特性）。</p>
</li>
<li>
<p>名词解释：定长编码，变长编码、前缀码</p>
<ul>
<li>定长编码：像ASCII编码</li>
<li>变长编码：单个编码的长度不一致，可以根据整体字符出现频率来调节</li>
<li>前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀</li>
</ul>
</li>
<li>
<p>理清思路：</p>
<ol>
<li>build a priority queue (权值从小到大排列)</li>
<li>build a huffmanTree</li>
<li>build a huffmanTable (存放哈夫曼的编码)</li>
<li>encode</li>
<li>decode</li>
</ol>
</li>
</ul>
<p><img src="Snipaste_2023-12-06_16-15-05.jpg" alt="Snipaste_2023-12-06_16-15-05"></p>
<ul>
<li>左子树都是用0来表示，右子树用1来表示，上图有些问题，忽略就好。</li>
</ul>
<h1>Day16</h1>
<h2 id="图">图</h2>
<ul>
<li>在前边讲解的线性表中，每个元素之间只有一个直接前驱和一个直接后继，在树形结构中，数据元素之间是层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。</li>
<li>但这仅仅都只是一对一，一对多的简单模型，如果要研究如人与人之间关系就非常复杂了。</li>
<li>万恶图为首，前面可能有些童鞋会感觉树的术语好多，可来到了图这章节，你才知道什么叫做真正的术语多！</li>
</ul>
<h2 id="图的定义">图的定义</h2>
<ul>
<li>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V, E), 其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</li>
</ul>
<p><img src="Snipaste_2023-12-07_17-11-29.jpg" alt="Snipaste_2023-12-07_17-11-29"></p>
<ul>
<li>对于图的定义，我们需要明确几个需要注意的地方：
<ul>
<li>线性表中我们把数据元素叫元素，树中叫节点，在图中数据元素我们则称之为顶点（Vertex）。</li>
<li>线性表可以没有数据元素，称为空表，树中可以没有节点，叫做空树，而图结构在咱国内大部分的教材中强调顶点集合V要有穷非空。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的节点具有层次关系，而图结构中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</li>
</ul>
</li>
</ul>
<h2 id="图的各种奇葩定义">图的各种奇葩定义</h2>
<p><img src="Snipaste_2023-12-07_17-22-07.jpg" alt="Snipaste_2023-12-07_17-22-07"></p>
<p><img src="Snipaste_2023-12-08_10-37-06.jpg" alt="Snipaste_2023-12-08_10-37-06"></p>
<p><img src="Snipaste_2023-12-08_10-38-47.jpg" alt="Snipaste_2023-12-08_10-38-47"></p>
<p><img src="Snipaste_2023-12-08_10-40-48.jpg" alt="Snipaste_2023-12-08_10-40-48"></p>
<p><img src="Snipaste_2023-12-08_10-42-57.jpg" alt="Snipaste_2023-12-08_10-42-57"></p>
<p><img src="Snipaste_2023-12-08_10-46-10.jpg" alt="Snipaste_2023-12-08_10-46-10"></p>
<p><img src="Snipaste_2023-12-08_10-48-49.jpg" alt="Snipaste_2023-12-08_10-48-49"></p>
<h2 id="图的顶点与边之间的关系">图的顶点与边之间的关系</h2>
<p><img src="Snipaste_2023-12-08_10-53-53.jpg" alt="Snipaste_2023-12-08_10-53-53"></p>
<p><img src="Snipaste_2023-12-08_10-56-41.jpg" alt="Snipaste_2023-12-08_10-56-41"></p>
<p><img src="Snipaste_2023-12-08_10-58-08.jpg" alt="Snipaste_2023-12-08_10-58-08"></p>
<p><img src="Snipaste_2023-12-08_10-59-47.jpg" alt="Snipaste_2023-12-08_10-59-47"></p>
<p><img src="Snipaste_2023-12-08_11-06-49.jpg" alt="Snipaste_2023-12-08_11-06-49"></p>
<h2 id="连通图">连通图</h2>
<p><img src="Snipaste_2023-12-08_11-08-44.jpg" alt="Snipaste_2023-12-08_11-08-44"></p>
<ul>
<li>无向图中的极大连通子图称为连通分量。</li>
<li>注意以下概念：
<ul>
<li>首先是子图</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-08_16-34-36.jpg" alt="Snipaste_2023-12-08_16-34-36"></p>
<ul>
<li>最后我们再来看连通图的生成树定义</li>
<li>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。（但不是满足此条件就是连通图的生成树）</li>
</ul>
<p><img src="Snipaste_2023-12-08_16-42-17.jpg" alt="Snipaste_2023-12-08_16-42-17"></p>
<h1>Day17</h1>
<h2 id="图的存储结构">图的存储结构</h2>
<ul>
<li>图的存储结构相比较线性表与树来说就复杂很多。</li>
<li>我们回顾下，对于线性表来说，是一对一的关系，所以用数组或者链表均可简单存放。树结构是一对多的关系，所以我们要将数组和链表的特性结合在一起才能更好的存放。</li>
<li>那么我们的图，是多对多的情况，另外图上的任何一个顶点都可以被看做是第一个顶点。</li>
<li>我们仔细观察以下几张图，然后深刻领悟一下：</li>
</ul>
<p><img src="Snipaste_2023-12-08_17-05-10.jpg" alt="Snipaste_2023-12-08_17-05-10"></p>
<p>（上面的四张图都是一样的）</p>
<ul>
<li>因为任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系（内存物理位置是线性的，图的元素关系是平面的）。</li>
<li>如果用多重链表来描述倒是可以做到，但在几节课前的树章节我们已经讨论过，纯粹用多重链表导致的浪费是无法想象的（如果各个顶点的度数相差太大，就会造成巨大的浪费）。</li>
<li>所幸，前辈们已经帮我们想好了出路，我们接下来会谈图的五种不同的存储结构，大家做好准备哦~</li>
</ul>
<h2 id="邻接矩阵（无向图）">邻接矩阵（无向图）</h2>
<ul>
<li>考虑到图是由顶点和边或弧两部分组成，合在一起比较困难，那就很自然地考虑到分为两个结构来分别存储。</li>
<li>顶点因为不区分大小、主次，所以用一个一维数组来存储是很不错的选择。</li>
<li>而边或弧由于是顶点与顶点之间的关系，一维数组肯定就搞不定了，那我们不妨考虑用一个二维数组来存储。</li>
<li>于是我们的邻接矩阵方案就诞生了！</li>
</ul>
<p><img src="Snipaste_2023-12-08_17-49-52.jpg" alt="Snipaste_2023-12-08_17-49-52"></p>
<ul>
<li>我们可以设置两个数组，顶点数组为vertex[4]={V0, V1, V2, V3}，边数组arc[4][4]为对称矩阵（0表示不存在顶点间的边，1表示顶点间存在边）。</li>
<li>对称矩阵：所谓对称矩阵就是n阶矩阵的元满足a[i][j]=a[j][i] (0&lt;=i, j&lt;=n)。即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的。</li>
<li>有了这个二维数组组成的对称矩阵，我们就可以很容易知道图中的信息：
<ul>
<li>要判定任意两顶点是否有边无边就非常容易了</li>
<li>要知道某个顶点的度，其实就是这个顶点Vi在邻接矩阵中第i行（或第i列）的元素之和。</li>
<li>求顶点Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点咯。</li>
</ul>
</li>
</ul>
<h2 id="邻接矩阵（有向图）">邻接矩阵（有向图）</h2>
<p><img src="Snipaste_2023-12-08_18-42-42.jpg" alt="Snipaste_2023-12-08_18-42-42"></p>
<ul>
<li>可见顶点数组vertex[4]={V0, V1, V2, V3}，弧数组arc[4][4]也是一个矩阵，但因为是有向图，所以这个矩阵并不对称，例如由V1到V0有弧，得到arc[1][0]=1，而V0到V1没有弧，因此arc[0][1]=0</li>
<li>另外有向图是有讲究的，要考虑入度和出度，顶点V1的入度为1，正好是第V1列的各数之和，顶点V1的出度为2，正好是第V1行的各数之和。</li>
</ul>
<h2 id="邻接矩阵（网）">邻接矩阵（网）</h2>
<p><img src="Snipaste_2023-12-08_18-58-55.jpg" alt="Snipaste_2023-12-08_18-58-55"></p>
<h2 id="邻接表（无向图）">邻接表（无向图）</h2>
<ul>
<li>邻接矩阵看上去是个不错的选择，首先是容易理解，第二是索引和编排都很舒服~</li>
<li>但是我们也发现，对于边数相对顶点较少的图，这种结构无疑存在对存储空间的极大浪费。</li>
</ul>
<p><img src="Snipaste_2023-12-08_19-05-28.jpg" alt="Snipaste_2023-12-08_19-05-28"></p>
<ul>
<li>因此我们可以考虑另外一种存储结构方式，例如把数组与链表结合一起来存储，这种方式在图结构也适用，我们称为邻接表（AdjacencyList）。</li>
<li>邻接表的处理方法是这样：
<ul>
<li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。</li>
<li>图中每个顶点Vi的所有邻接点看成一个线性表，由于邻接点的个数不确定，所以我们选择用单链表来存储。</li>
</ul>
</li>
</ul>
<p><img src="Snipaste_2023-12-08_19-46-19.jpg" alt="Snipaste_2023-12-08_19-46-19"></p>
<h2 id="邻接表（有向图）">邻接表（有向图）</h2>
<p><img src="Snipaste_2023-12-08_19-49-56.jpg" alt="Snipaste_2023-12-08_19-49-56"></p>
<p><img src="Snipaste_2023-12-08_19-51-44.jpg" alt="Snipaste_2023-12-08_19-51-44"></p>
<p><img src="Snipaste_2023-12-08_19-53-21.jpg" alt="Snipaste_2023-12-08_19-53-21"></p>
<h1>Day18</h1>
<h2 id="图的遍历">图的遍历</h2>
<p>树的遍历我们谈了四种方式，大家回忆一下，树因为根节点只有一个，并且所有的节点都只有一个双亲，所以不是很难理解。</p>
<p>但是谈到图的遍历，那就复杂多了，因为它的任一顶点都可以和其余的所有顶点相邻接，因此极有可能存在重复走过某个顶点或漏了某个顶点的遍历过程。</p>
<p>对于图的遍历，如果要避免以上情况，那就需要科学的设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。</p>
<h2 id="深度优先遍历">深度优先遍历</h2>
<ul>
<li>深度优先遍历（DepthFirstSearch），也有称为深度优先搜索，简称为DFS。</li>
<li>它的具体思想类似于课程开头讲的找钥匙方案，无论从哪一间房间开始都可以，将房间内的墙角、床头柜、床上、床下、衣柜、电视柜等挨个寻找，做到不放过任何一个死角，当所有的抽屉、储藏柜中全部都找遍，接着再寻找下一个房间。</li>
<li>现在大家一起来想办法走以下这个迷宫，要求</li>
</ul>
<p><img src="Snipaste_2023-12-08_21-42-34.jpg" alt="Snipaste_2023-12-08_21-42-34"></p>
<ul>
<li>我们可以约定右手原则：在没有碰到重复顶点的情况下，分岔路口始终是向右手边走，每路过一个顶点就做一个记号。</li>
<li>接下来有请小甲鱼童鞋带我们走迷宫去。</li>
<li>迷宫走完了，所有的顶点也遍历过了，这就是深度优先遍历！</li>
<li>反应快的童鞋一定会感觉深度优先遍历其实就是一个递归的过程嘛~</li>
</ul>
<p><img src="Snipaste_2023-12-08_22-26-41.jpg" alt="Snipaste_2023-12-08_22-26-41"></p>
<p>（只看蓝色线，前序遍历）</p>
<h2 id="广度优先遍历">广度优先遍历</h2>
<p><img src="Snipaste_2023-12-08_22-43-54.jpg" alt="Snipaste_2023-12-08_22-43-54"></p>
<p><img src="Snipaste_2023-12-08_22-46-17.jpg" alt="Snipaste_2023-12-08_22-46-17"></p>
<p>（只看右边蓝色线，层序遍历）</p>
<p><img src="Snipaste_2023-12-08_22-53-57.jpg" alt="Snipaste_2023-12-08_22-53-57"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://dianfengchen.github.io/">点风尘 (Ethan)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://dianfengchen.github.io/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://dianfengchen.github.io/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://dianfengchen.github.io" target="_blank">点风尘の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-share"><div class="social-share" data-image="https://bu.dusays.com/2025/11/27/69273863d4308.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://bu.dusays.com/2025/11/28/6929bbb93e53f.jpg" target="_blank"><img class="post-qr-code-img" src="https://bu.dusays.com/2025/11/28/6929bbb93e53f.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://bu.dusays.com/2025/11/28/6929bbb939a5e.jpg" target="_blank"><img class="post-qr-code-img" src="https://bu.dusays.com/2025/11/28/6929bbb939a5e.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/10/04/%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E5%BA%93%E2%80%94%E2%80%94pyautogui/" title="一个好玩的鼠标键盘库——pyautogui"><img class="cover" src="https://bu.dusays.com/2025/11/27/69273be43f3ee.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">一个好玩的鼠标键盘库——pyautogui</div></div><div class="info-2"><div class="info-item-1">分享一下pyautogui库的用法~</div></div></div></a><a class="pagination-related" href="/2023/11/26/%E8%B6%85%E9%AB%98%E9%A2%91%E5%9C%B0%E9%81%93%E9%80%A0%E5%8F%A5%E5%85%AC%E5%BC%8F/" title="超高频地道造句公式"><img class="cover" src="https://bu.dusays.com/2025/11/27/69273863d4de2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">超高频地道造句公式</div></div><div class="info-2"><div class="info-item-1">一些英语学习笔记。</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://bu.dusays.com/2025/11/29/692aa597c2c49.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">点风尘 (Ethan)</div><div class="author-info-description">2025年的理想开始实现了吗？</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/dianfengchen" target="_blank" title="Github"><i class="fab fa-github" style="color: #181717;"></i></a><a class="social-icon" href="mailto:microswordsman@126.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #EA4335;"></i></a><a class="social-icon" href="https://bu.dusays.com/2025/11/26/6926ddd142377.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin" style="color: #1AAD19;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Day0</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">算法的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">算法设计要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%86%E5%A4%87%E7%8E%AF%E8%8A%82%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">算法效率的度量方法（准备环节）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Day1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">推导大O阶方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Day2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.1.</span> <span class="toc-text">常见的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5"><span class="toc-number">3.2.</span> <span class="toc-text">最坏情况与平均情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">算法的空间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.</span> <span class="toc-text">线性表的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2"><span class="toc-number">3.5.2.</span> <span class="toc-text">抽象数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Day3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">线性表的抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Day4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">线性表的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">地址计算方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.2.</span> <span class="toc-text">获得元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.3.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.4.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.1.5.</span> <span class="toc-text">线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">线性表的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">线性表链式存储结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.2.</span> <span class="toc-text">单链表存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">5.2.3.</span> <span class="toc-text">单链表的读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Day5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">栈的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.</span> <span class="toc-text">栈的插入和删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">栈的顺序存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A0%88"><span class="toc-number">6.4.</span> <span class="toc-text">创建一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.</span> <span class="toc-text">入栈操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">6.6.</span> <span class="toc-text">出栈操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Day6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E9%97%AE%E8%A7%A3%E9%87%8A"><span class="toc-number">7.1.</span> <span class="toc-text">疑问解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E4%B8%80%E4%B8%AA%E6%A0%88"><span class="toc-number">7.2.</span> <span class="toc-text">清空一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E4%B8%80%E4%B8%AA%E6%A0%88"><span class="toc-number">7.3.</span> <span class="toc-text">销毁一个栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%88%E7%9A%84%E5%BD%93%E5%89%8D%E5%AE%B9%E9%87%8F"><span class="toc-number">7.4.</span> <span class="toc-text">计算栈的当前容量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">7.5.</span> <span class="toc-text">实例分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%B0%E5%85%AB%E8%BF%9B%E5%88%B6"><span class="toc-number">7.6.</span> <span class="toc-text">从二进制到八进制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Day7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.2.</span> <span class="toc-text">字符串的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.</span> <span class="toc-text">字符串的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BF%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">BF算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">Day8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%90%AF%E5%8F%91"><span class="toc-number">9.1.</span> <span class="toc-text">思路启发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1"><span class="toc-number">9.1.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2"><span class="toc-number">9.1.2.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3"><span class="toc-number">9.1.3.</span> <span class="toc-text">3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4"><span class="toc-number">9.1.4.</span> <span class="toc-text">4</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8D%E6%80%9D%E8%80%83%E4%B8%8D%E8%A6%81%E6%B3%A8%E9%87%8D%E7%BB%93%E6%9E%9C"><span class="toc-number">9.2.</span> <span class="toc-text">注重思考不要注重结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">Day9(KMP算法之养成篇)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E4%B9%8BNEXT%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">10.1.</span> <span class="toc-text">KMP算法之NEXT数组代码原理分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">Day10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">节点分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.3.</span> <span class="toc-text">节点间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">11.4.</span> <span class="toc-text">节点的层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5"><span class="toc-number">11.5.</span> <span class="toc-text">其他概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">Day11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">12.1.1.</span> <span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">12.1.2.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">12.1.3.</span> <span class="toc-text">孩子表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">12.1.4.</span> <span class="toc-text">双亲孩子表示法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Day12</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">13.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">13.2.</span> <span class="toc-text">二叉树的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81"><span class="toc-number">13.3.</span> <span class="toc-text">二叉树的五种基本形态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BE%88%E4%BA%8C"><span class="toc-number">13.4.</span> <span class="toc-text">二叉树很二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">13.5.</span> <span class="toc-text">特殊二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%9C%E6%A0%91"><span class="toc-number">13.5.1.</span> <span class="toc-text">斜树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">13.5.2.</span> <span class="toc-text">满二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">Day13</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">14.1.</span> <span class="toc-text">二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%80%EF%BC%9A"><span class="toc-number">14.1.1.</span> <span class="toc-text">性质一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%BA%8C%EF%BC%9A"><span class="toc-number">14.1.2.</span> <span class="toc-text">性质二：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%89%EF%BC%9A"><span class="toc-number">14.1.3.</span> <span class="toc-text">性质三：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E5%9B%9B%EF%BC%9A"><span class="toc-number">14.1.4.</span> <span class="toc-text">性质四：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8%E4%BA%94%EF%BC%9A"><span class="toc-number">14.1.5.</span> <span class="toc-text">性质五：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.2.1.</span> <span class="toc-text">二叉树的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">14.2.2.</span> <span class="toc-text">二叉链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">Day14</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">15.1.</span> <span class="toc-text">二叉树的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">Day15</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">16.1.</span> <span class="toc-text">赫夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">16.1.1.</span> <span class="toc-text">赫夫曼树定义与原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">16.2.</span> <span class="toc-text">赫夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">Day16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">17.1.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">17.2.</span> <span class="toc-text">图的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%90%84%E7%A7%8D%E5%A5%87%E8%91%A9%E5%AE%9A%E4%B9%89"><span class="toc-number">17.3.</span> <span class="toc-text">图的各种奇葩定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%B6%E7%82%B9%E4%B8%8E%E8%BE%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.4.</span> <span class="toc-text">图的顶点与边之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE"><span class="toc-number">17.5.</span> <span class="toc-text">连通图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">Day17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">18.1.</span> <span class="toc-text">图的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">18.2.</span> <span class="toc-text">邻接矩阵（无向图）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">18.3.</span> <span class="toc-text">邻接矩阵（有向图）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%88%E7%BD%91%EF%BC%89"><span class="toc-number">18.4.</span> <span class="toc-text">邻接矩阵（网）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">18.5.</span> <span class="toc-text">邻接表（无向图）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">18.6.</span> <span class="toc-text">邻接表（有向图）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">Day18</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">19.1.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">19.2.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">19.3.</span> <span class="toc-text">广度优先遍历</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/11/28/hexo%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%EF%BC%9F%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E6%98%AF%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%81/" title="hexo本地预览图片不显示？原因竟然是渲染器！"><img src="https://bu.dusays.com/2025/11/28/6929ad216da1b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo本地预览图片不显示？原因竟然是渲染器！"/></a><div class="content"><a class="title" href="/2025/11/28/hexo%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%EF%BC%9F%E5%8E%9F%E5%9B%A0%E7%AB%9F%E7%84%B6%E6%98%AF%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%81/" title="hexo本地预览图片不显示？原因竟然是渲染器！">hexo本地预览图片不显示？原因竟然是渲染器！</a><time datetime="2025-11-28T10:04:21.000Z" title="发表于 2025-11-28 18:04:21">2025-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/01/hello-world/" title="Hello World"><img src="https://bu.dusays.com/2025/11/27/69273863d4e07.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/11/01/hello-world/" title="Hello World">Hello World</a><time datetime="2025-10-31T17:03:13.191Z" title="发表于 2025-11-01 01:03:13">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/26/Python%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8/" title="Python中的图像处理利器"><img src="https://bu.dusays.com/2025/11/27/69273863ddaea.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python中的图像处理利器"/></a><div class="content"><a class="title" href="/2024/05/26/Python%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8/" title="Python中的图像处理利器">Python中的图像处理利器</a><time datetime="2024-05-26T07:30:22.000Z" title="发表于 2024-05-26 15:30:22">2024-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/26/%E8%B6%85%E9%AB%98%E9%A2%91%E5%9C%B0%E9%81%93%E9%80%A0%E5%8F%A5%E5%85%AC%E5%BC%8F/" title="超高频地道造句公式"><img src="https://bu.dusays.com/2025/11/27/69273863d4de2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超高频地道造句公式"/></a><div class="content"><a class="title" href="/2023/11/26/%E8%B6%85%E9%AB%98%E9%A2%91%E5%9C%B0%E9%81%93%E9%80%A0%E5%8F%A5%E5%85%AC%E5%BC%8F/" title="超高频地道造句公式">超高频地道造句公式</a><time datetime="2023-11-26T15:20:08.000Z" title="发表于 2023-11-26 23:20:08">2023-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img src="https://bu.dusays.com/2025/11/27/69273863d4308.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/2023/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2023-11-04T10:19:37.000Z" title="发表于 2023-11-04 18:19:37">2023-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 点风尘 (Ethan)</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>